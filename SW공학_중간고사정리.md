# 1. 소프트웨어 개발
### 1-1. 소프트웨어 개발의 유래
- 소프트웨어 개발의 행위는 여러 행위가 있다.
- 취미, Excel, 데이터 처리 등등 여러 행위가 존재한다.

### 1-2. 전문적 소프트웨어 개발
- 독립된 다른 사용자를 위해 소프트웨어를 개발하는 것.
- 혼자가 아닌 팀단위의 개발을 의미함

### 1-3. 소프트웨어 제품의 유형
#### 1-3.1. Generic Products
- 단독 제품으로 만들어져 오픈 마켓을 톻애 사용자에게 판매하는 소프트웨어
- 예시 : 스마트폰 앱, PC용 SW등
- 소프트웨어 명세를 개발하는 회사가 결정함
#### 1-3.2. Customized(or Bespoke) Software
- 특정 고객으로부터 의뢰받아 제작되는 소프트웨어
- 예시 : 쇼핑몰 회사의 자체 웹페이지 제작, 전자장치 제어모듈 주문제작, 업무관리 시스템 등
- 소프트웨어 명세를 소프트웨어를 발주할 사용자가 결정함

### 1-4. 개발과정 요약
![image](https://user-images.githubusercontent.com/99636945/196606542-b75a9747-dd16-442d-afb2-e3da5135621d.png)

### 1-5. 필요성
- 좋은 소프트웨어를 만들고자 하는 취지
- 기준은 소프트웨어의 품질을 판단하는 요소의 만족 여부로 정한다.

### 1-6. 품질의 중요요소
- 수용성(Acceptability) : 대상이 되는 사용자가 이해하기 쉽고 유용하며, 다른 시스템과 호환되어야 함
- 신뢰도와 보안(Dependability and security) : 자체적 혹은 외부의 공격에 의한 문제가 생겨도 물리/경제적 피해가 발생하지 않아야 함
- 효율성(Efficiency) : 불필요한 리소스 사용을 최소화 하고 일정 응답속도 및 성능을 보장해야 함
- 유지보수성(Maintainability) : 반드시 발 수 밖에 없는 소프트웨어의 기능 변경에 대응할 수 있도록 소프트웨어가 작성되어야 함
- 개발해야 하는 SW에 따라서 지켜져야 하는 품질 요소는 달라질 수 있음

### 1-7. 소프트웨어 엔지니어링
- 소프트웨어는 프로그램 및 관련 문서(매뉴얼, 웹사이트), 라이브러리를 포함하는 개념이고 고객 혹은 범용 목적으로 개발될 수 있음
- 좋은 소프트웨어는 필요 기능을 제공하고, 요구 성능을 보장하고, 유지보수가 가능해야 하며, 신뢰할 수 있어야 하고 사용성이 좋아야 한다.
- 초기 구성부터 운영 및 유지보수 과정 등 전문적인 소프트웨어 제품을 만드는데 필요한 모든 과정에 대한 규율
- 명세(Specification), 개발(Development), 검증(Validation), 개선(Evolution)등의 행위를 포함한다.

#### 1-7.1 공학적 규율
- 엔지니어가 업무를 수행함에 있어서 아래 두가지를 만족하는 것
- 적절한 방법론, 툴을 선별하여 적용하거나 방법론이 없어도 문제를 해결하기 위해 시도하는 행위
- 조직 수준에서의 제약과 예산의 문제를 고려하여 주어진 일정 내에 업무를 완수하는 것

# 2. 소프트웨어 개발 주기
### 2-1. SDLC(Software Development Life-Cycle) 모델
- 모든 유형의 소프트웨어에 공통 적용이 가능한 개발 주기는 없으나, 필수적인 행동은 다음과 같음
![image](https://user-images.githubusercontent.com/99636945/196609615-44f3dfe3-4854-47cb-b8e7-ec7bfb5fe04c.png)
- 위 그림의 필수적 활동을 어떤 방식으로 수행하는지에 따라 개발 주기를 구분할 수 있음

#### 2-1.1 계획 주도 모델
- 소프트웨어 개발 주기의 활동을 미리 계획하고, 이에 따른 진척도를 측정하는 모델(대표적으로 폭포수 모델이 여기에 속함)

#### 2-1.2 애자일 모델
- 소프트웨어 전체가 아닌 일부분에 대해서, 요구사항 분석에서부터 설계, 구현, 테스트, 배포까지의 모든 활동을 수행하고
- 계획주도 모델이 전체 SW를 초기에 모두 계획하고 진행하는 것과 상반됨

### 2-2. 폭포수 모델
- 1970년대 군사 무기 시스템을 만들던 공학적 절차에서 고안됨
- 요구사항 분석 단계에서 고정된 요구사항을 갖고 전체 개발 절차가 진행되는 방법론
- 이론적으론 앞단계가 완료 되어야 넘어갈 수 있으며, 전체가 진행되어야 이전 프로세스가 재수행될 수 있음
![image](https://user-images.githubusercontent.com/99636945/196610346-50788cc2-02a0-47da-b898-f2a117d0f7f9.png)
#### 2-2.1. 단계별 절차
- 요구사항 분석 : 사용자로부터 시스템에서 제공하는 서비스 및 제약사항, 목표를 수립하고 명세를 구체화하는 단계
- 시스템 및 SW 설계 : 요구사항을 S/W 형태로 할당하고, 전체 시스템 아키텍쳐를 수립하는 단계
- 구현 및 유닛 테스트 : 설계된 내용이 실제 프로그램 및 유닛들로 만들어지는 단계, 단위 테스트로 명세를 제대로 구현했는지 검증함
- 통합 및 테스트 : 프로그램 단위를 하나의 시스템으로 통합하고 테스트하는 단계
- 운영 및 유지보수 : 일반적으로 가장 긴 단계, 확인되지 않은 에러를 발견하고 해결하거나, 코드 개선, 새로운 요구사항을 발견하며 시스템 개선
#### 2-2.2. 단점
- 변경사항이 발생하더라도 개발 중에는 이를 반영할 수 없음
- 문서가 아닌 비공식적인 팀 내 대화가 많고, 변경사항이 자주 발생하는 경우 적합하지 않음
- 분석부터 설계에 이르기 까지 문서화해야 할 내용이 오히려 부하로 작용
- 설게에서 고려되어야 하는 내용이 미처 파악되지 못하고 상당히 구현진행 된 경우 파악되는 문제 발생
#### 2-2.3. 적절한 사용
- 요구사항 이해가 쉽고, 변경이 잘 발생하지 않는 경우에 적합
- RDBMS 개발에 적합

### 2-3. 애자일 모델
- Agile : 날렵한, 민첩한 이라는 사전적 의미를 지님
- 소프트웨어를 최단시간에 배포할 수 있도록 불필요 행위를 배제하면서 요구사항의 변화에 빠르게 대응 가능한 점진적 개발 방법론
- 계획 주도 모델의 단점을 극복하기 위해 설계 및 문서화보다 프로그램 자체에 집중
- 애자일 모델을 기반으로 한 다른 방법론이 계속 제시되어옴
- 익스트림 프로그래밍, 스크럼 등등
#### 2-3.1. 공통 특징
- 모든 애자일 방법론은 소프트웨어의 전체 기능에 대해 부분적인 기능에 대한 점진적인 개발 과정을 수행함
![image](https://user-images.githubusercontent.com/99636945/196611651-f1fd4210-6def-4af2-bdb9-b2e7efdf8c81.png)
#### 2-3.2 단점
- 임베디드 시스템 및 규모가 크고 복잡한 시스템을 만드는 경우 문제 발생
- 명세를 확정짓지 못해 법적 계약서에 내용을 명시하는데 어려움 발생
- 계약 당시와 다른 요구가 포함되거나 빠지는 경우가 발생
- 신규 소프트웨어 개발에는 적합하나 유지보수에는 부적절
- 고객을 지속적으로 애자일 프로세스에 참여시키기가 어려움
- 문서가 적기에 이후 개선작업 수행하는 팀이 원래 개발한 팀이 아닐 경우 유지보수 불가능한 상태가 될 수 있음

### 2-4. 결론
- 실제 업무에서는 두 방법을 필요에 따라 부분적으로 적용시키기도 함
- 옳고 그름은 없고, 선택의 문제이므로 목적에 맞는 적절한 방법론 선택이 중요

# 3. 요구사항 분석과 모델링의 필요성
### 3-1. 왜 요구사항 분석과 모델링을 해야하는가?
- 요구사항 전달받고, 모델링 없이 머릿속으로 설계하고 일정을 산출해도 문제가 없을수도 있음
- 항상 잘 작동하지 않으며, 변경이 발생함에따라 전제 시스템의 설계가 틀어지는 경우도 발생
- 분석과 모델링은 개발자가 만들려는 시스템 이해를 높이고, 고객과 원활한 의사소통을 통해 불필요한 변경을 최소화 할 수 있음
- 시간이 지나면 코드로는 파악하지 못할 사실들을 문서를 통해 기억할 수 있게 함

### 3-2. 요구사항
- 시스템이 제공해야 할 서비스와 서비스가 동작중에 지켜져야 할 제약사항을 의미
- 육하원칙에 따라 작성되어야 전달력 높은 문서가 될 수 있음
#### 3-2.1 요구사항의 유형
- 사용자 요구사항 : 서비스가 제공해야 할 기능이나 지켜야 할 제약사항을 문장이나 다이어그램을 통해 고차원적이고 추상적으로 표현한 것
- 시스템 요구사항 : 서비스가 제공해야 할 기능이나 지켜야 할 제약사항에 대한 세부적인 명세를 구조화된 문서 및 다이어그램으로 작성한 것
#### 3-2.2. 기능과 제약사항
- 시스템이 제공해야 할 기능을 기능적 요구사항이라고 함
- 시스템 전체에서 지켜져야 할 제약사항을 비기능적 요구사항이라고 함
#### 3-2.3. 사용자 요구사항 및 시스템 요구사항 예시
![image](https://user-images.githubusercontent.com/99636945/196613690-d34ae80c-a8ff-4979-bc9c-da5961348d0f.png)
#### 3-2.4. 기능적/비기능적 요구사항 예시
![image](https://user-images.githubusercontent.com/99636945/196613781-433483c2-9f34-4776-8e80-0348ab534826.png)

### 3-3. 요구사항 명세
- 요구사항의 명세란 사용자 요구사항과 시스템 요구사항을 문서로 작성하는 행위
- 사용자 요구사항은 기술적 배경지식이 없는 최종사용자와 발주 고객이 이해할 수 있어야 함
- 시스템 요구사항은 기술적 정보들이 포함되어도 무방(개발자는 주로 시스템 요구사항 작성)
- 특히, 시스템 요구사항을 기술하는 방법은 여러가지가 존재
- 자연어 : 한 문장에 한 가지 요구사항을 기술
- 도표 기반 표기법 : 텍스트 주석을 보조적으로 사용하는 도표 기반 모델을 통해 요구사항 기술
- 시스템이 제공해야 할 기능을 도표 기반으로 작성하는 것을 모델링이라고 함

### 3-4. 시스템 모델링
- 시스템 요구사항을 도표기반 모델링 기법을 활용해 모델을 만드는 것
- 종류가 다양하고, 시스템이 가질 수 있는 서로 다른 측면을 표현하기 떄문에 여러가지 기법으로 다양한 모델을 만들어 시스템을 표현할 필요가 있음
- 시스템 모델에서 가장 보편적으로 사용되는 것은 **UML(Unified Modeling Language)** 임
- 주의사항 : 완벽하게 표현하지 못하며, 이해를 돕기 위한 보조적인 역할을 수행할 뿐임

### 3-5. UML
- 소프트웨어 시스템을 모델링하기 위한 13가지 종류의 표기법들의 집합
- 객체지향 모델링을 위해 등장하였고 비슷한 모델들을 흡수하여 2004년에 UML2라는 최종버전 표준이 완성됨
- 가장 대표적으로 Activity, Use Case, Sequence, Class, State 다이어그램이 존재한다

### 3-6. Activity Diagram
- 시스템이 적용될 업무의 흐름을 행위 단위로 절차를 표현하는 다이어 그램
- 어떤 행위에서 다음 행위로 넘어갈 때 제어흐름을 표현할 수 있음
- High-Level 모델 중 하나
- 아주 세세한 모델이 아닌 시스템 개요나 시스템 일부를 표현하기 위해 사용
#### 3-6.1. 표기법
![image](https://user-images.githubusercontent.com/99636945/196616251-56680f0f-6f55-4208-8e5c-58a40acff490.png)
![image](https://user-images.githubusercontent.com/99636945/196616281-09428972-545d-420f-8452-6d97e53f8f09.png)
![image](https://user-images.githubusercontent.com/99636945/196616350-e8801549-3566-4b61-a8e3-a747d6e4335d.png)
#### 3-6.2. 샘플
![실습과제샘플-Activity](https://user-images.githubusercontent.com/99636945/196616503-04e32a8f-dace-4fc5-82ee-5adf4118ec2f.png)

### 3-7. SwimLane Diagram
- 시스템이 적용될 업무 흐름을 나타내는 다이어그램, 업무를 수행하는 대상 사이 독립적으로 구분됨
- UML에 속하지는 않지만 업무 흐름을 표현할 때 자주 사용
- 액티비티와 유사하나 업무 흐름이 앤티티간 완벽히 분리되어 있는 것이 가장 큰 차이점
#### 3-7.1. 표기법
![image](https://user-images.githubusercontent.com/99636945/196617104-95c70fb4-6418-4b53-bb45-b29ed67da652.png)
![image](https://user-images.githubusercontent.com/99636945/196617164-4eeb2097-3884-4ed9-aead-13c85bece21b.png)
![image](https://user-images.githubusercontent.com/99636945/196617231-df461859-2fc9-4f99-bc6f-da307ed86baf.png)
![image](https://user-images.githubusercontent.com/99636945/196617302-cc7dd2f5-a04b-4d14-b313-52ef2f3f9373.png)
#### 3-7.2. 샘플
![3주차_실습1_swimlanes](https://user-images.githubusercontent.com/99636945/196617404-966314a9-0acd-4129-a8b1-bdde07d70785.png)

### 3-8. Use Case Diagram
- 사용자와 시스템 사이의 상호작용을 나타내는 다이어그램
- 행위의 주체가 되는 대상을 Actor(행위자)라고 함
- 행위를 나열하지만, 어떻게 처리되는지는 자세히 표현하지 않음
- 시스템 요구사항이 무엇인지 찾는데 유용하며, 제공하는 기능들에 대한 개요를 제공함
- 전체 심볼을 사용해 아주 자세히 표현이 가능하나 권장하는 방법은 아님(High-Level은 개발자 외에 일반인도 보기 때문)
- 유스케이스 단위를 독립적으로 기술하기에 용이한 기능 단위로 표현하는 것이 좋음
#### 3-8.1. 표기법
![image](https://user-images.githubusercontent.com/99636945/196623819-2128fffd-d00e-487f-a597-a6c2f7692aa7.png)
![image](https://user-images.githubusercontent.com/99636945/196623871-989f2458-57d3-46e5-97c7-8af398731c69.png)
![image](https://user-images.githubusercontent.com/99636945/196623906-a2ff0ba4-4153-4f58-a077-0eb113e3f4b7.png)
![image](https://user-images.githubusercontent.com/99636945/196624007-24db40b4-44af-405f-b071-25ec9c233da0.png)
#### 3-8.2. 샘플
![3주차_실습2_usecase](https://user-images.githubusercontent.com/99636945/196624196-43eb2d86-5c71-48bf-9fdc-94653983d628.png)

# 4. Low-Level 모델링

### 4-1. 클래스 다이어그램
- 객체지향 시스템 모델을 구현할 때 사용되며, 클래스들 간의 관계를 링크(Link)로 표현
- 실세계를 클래스로 변환하는 과정
#### 4-1.1. 표기법
![image](https://user-images.githubusercontent.com/99636945/196830289-5ad6cb44-b4ce-4404-8268-032fc898c4e0.png)
#### 4-1.2. 클래스 간의 관계(일반화)
- 어떤 대상을 파악할 때 구체적 틍성보단 일반적 분류로부터 출발
- Java나 Python에서의 상속으로 구현됨
- 하위 클래스는 상위 클래스의 속성과 연산을 물려받게 됨
- 하위 클래스는 상위 클래스의 속성과 연산 외에 자기 자신의 속성과 연산 추가 가능
- 변경사항 발생 시 모든 하위 클래스를 확인할 필요 없이 상위 클래스만 고려하면 됨
#### 4-1.3. 클래스 간의 관계(합성)
- 두 클래스 사이에 의존성이 존재함을 나타냄
- 의존성은 한 쪽 클래스에서 다른쪽 클래스로 발생
#### 4-1.4. 클래스 간의 관계(집합)
- 합성과 동일하나 한 가지 차이가 존재
- 의존성이 약해 한 쪽이 없어지더라도, 다른 한 쪽에 영향을 미치지 않음
#### 4-1.5. 샘플
![4주차_class_diagram](https://user-images.githubusercontent.com/99636945/196830891-060ff57b-9560-4c11-acf3-87054122448a.png)

### 4-2. 시퀀스 다이어그램
- 시스템을 구성하는 컴포넌트들 간의 상호작용을 표현하기 위한 다이어그램
- 컴포넌트를 무엇으로 하느냐에 따라 High, Low 레벨 모두 표현 가능
- Symbol의 종류가 다양해서 표현 가능한 상호작용이 매우 많음
#### 4-2.1. 표기법
![image](https://user-images.githubusercontent.com/99636945/196831076-229af293-2330-40ca-930a-3a68541e69c6.png)
#### 4-2.2. 샘플
![4주차_sequence_diagram](https://user-images.githubusercontent.com/99636945/196831168-e52bccd3-5405-4ff8-8ee2-8e23e8f5ce2f.png)

# 5. 소프트웨어 품질과 관련된 비기능적 속성

### 5-1. 기능/비기능적 요구사항
- 기능적 요구사항 : 시스템이 제공해야하는 기능임을 위에서 언급
- 비기능적 요구 사항 : 시스템을 구성하는 개별 컴포넌트 단위보다는 주로 전체 시스템 자원에서 만족되어야 하는 요건이나 제약사항
- 보안이나 성능 등 소프트웨어가 만족해야 하는 비기능적 품질 속성으로부터 비기능적 요구사항이 도출됨(비기능적 요구사항 = 품질 속성)
- 비기능적 요구사항을 만족시키기 위해 또 다른 기능적 요구사항이 파생되곤 함
- 비기능적 요구사항은 이미 정해져 있는 경우가 많음

### 5-2. 소프트웨어의 발전 과정과 아키텍쳐 패턴
![image](https://user-images.githubusercontent.com/99636945/196831678-82fdf1f6-3e33-4552-9399-ec1e5bed7590.png)
- 엄청나게 많은 소프트웨어가 개발 되고 있음(같은분야, 비슷한 목적)
#### 5-2.1. 아키텍쳐와 소프트웨어 산업과의 관계
- 어플리케이션은 기업이나 기관의 필요를 만족시키기 위해 주로 개발됨
- 모든 기업활동은 서로 공통분모가 있으며, 비슷한 사업 분야는 동일 목적의 어플리케이션에 대한 개발이 필요함
- 만족해야 할 소프트웨어 품질 속성과 어떻게 만족시킬 수 있는지 등을 특정 유형의 시스템에 대한 아키텍쳐로 발전시킴
- 이를 위해서 확인해야 할 것은 3가지이다.  
![image](https://user-images.githubusercontent.com/99636945/196831849-56c6d299-f815-4b99-a6dc-8af6abb69ae7.png)

### 5-3. 비기능적 품질 속성의 종류
![image](https://user-images.githubusercontent.com/99636945/196831932-5f13b48c-5375-45c1-a3f4-167ffb3ae92a.png)
#### 5-3.1. 신뢰도
- 일반적인 상황에서 시스템이 의도대로 동작하고, 실패하지 않을 것이라는 사실에 대한 확신의 정도
- 시스템 실패는 반드시 발생하므로, 어떻게 통제할 것인지가 기준이 됨
- 신뢰도가 더 중요한 이유는 다음 4가지로 설명할 수 있다.
- 1. 시스템 실패는 많은 수의 사람들에게 영향을 미침
- 2. 사용자는 신뢰도가 낮은 시스템의 사용을 거부하게 됨
- 3. 시스템 실패로 인해 지불해야 하는 비용이 매우 클 수 있음
- 4. 신뢰도가 낮은 시스템은 정보의 손실을 유발할 수 있음
#### 5-3.2. 시스템 결함과 실패의 차이
- 결함 : 잘못된 동작을 유발할 수 있는 특성(버그로 인해 발생)
- 실패 : 시스템이 실제로 잘못된 동작을 일으키거나 동작을 멈추는 것
- 최소화 노력으로 인한 방법론은 다음과 같이 설명된다.
- 결함 회피 : 컴파일러가 다양한 유형의 코드 검증을 수행하는 언어를 사용하는 행위, 에러를 유발하기 쉬운 기능 사용 최소화
- 결함 탐지 및 정정 : 시스템 자원의 테스팅 및 디버깅 수행, 정적 분석 툴 사용
- 결함 감내 : 시스템이 동작하는 상황에서 결함을 탐지하고 실패로 이어지지 않는 방법으로 관리
- 런타임 검사 기능 사용 및 감내 아키텍쳐 도입도 도움이 될 수 있음
#### 5-3.3. 결함 감내 아키텍쳐
- 어쩔 수 없이 발생하는 것이므로 통제 방법이 필요함
- 발생은 피할 수 없으니 발샣했을 때도 시스템이 정상적으로 동작하게 해야함
![image](https://user-images.githubusercontent.com/99636945/196832509-37feabe5-b897-4438-a6d8-dd8d7d949a45.png)
#### 5-3.4. 신뢰도를 결정하는 요소
- 1. 가용성 : 시스템이 서비스를 제공할 수 있는 능력, 다양성과 다양화를 통해 확보한다. 수치화 하려면 (전체 시간 - 시스템 비정상 시간) / 전체시간 으로 계산한다.
- 2. 신뢰성 : 시스테이 서비스의 기능을 명세에 따라 제공하는 능력
- 3. 안전성 : 시스템이 대규모의 실패없이 정상적으로 동작하는 능력
- 4. 보안 : 고의적이고 급작스런 외부 침입에도 시스템이 스스로를 보호할 수 있는 능력
- 5. 회복탄력성 : 시스템에 손상이 발생하는 상황에 대해 저항하거나 스스로 복구할 수 있는 능력
- 서비스 별로 필요 가용성은 다음 표를 참조  
![image](https://user-images.githubusercontent.com/99636945/196832774-5e723792-9adf-4c5e-91c7-a7da7d28298d.png)
#### 5-3.5. 보안
- 다양하고 복잡하며, 계츠에 따라 표준화된 보안 방식이 존재
- 암호화 : 허가받지 않은 사용자에게 데이터를 노출하지 않도록 알고리즘으로 데이터를 변형하는 행위
- 저장된 데이터 뿐 아니라 컴포넌트 간 전송중인 데이터에 대한 암호화 필요
- 표준적 암호화 알고리즘이 이미 제시, 대부분 라이브러리 형태로 사용 가능 
- 접근제어 : 허용된 사용자만이 시스템에 접근하거나 특정 기능을 사용하도로 제약

# 6. 소프트웨어 형상 관리
### 6-1. 소프트웨어 형상 관리의 필요성
- 전문적인 소프트웨어는 팀 단위로 개발하므로, 분업 후 소스를 통합하는 과정을 거침
- 이 과정에서 소스코드의 충돌이 발생하며, 충돌에 대한 정리가 필요함
- 소프트웨어를 안정적으로 보관할 장소가 필요함
- 업데이트가 지속됨에 따라 기존 출시 제품에 대한 유지보수를 수행할 수 있어야 함
- 소스코드의 어디가 어떻게 변경되었는지, 왜 변경되었는지 추적이 필요함
- 추적이 필요한 이유는 다음 4가지로 정리할 수 있음  
![image](https://user-images.githubusercontent.com/99636945/196833492-418b9530-eb9f-474d-b3db-1803aab551b8.png)

### 6-2. 소프트웨어 형상 관리란?
- 개발하고 사용하는 동안 끊임없이 변화하는 소프트웨어를 관리하기 위해 사용되는 정책, 절차, 도구를 의미함.
- 4가지 활동으로 구분됨  
![image](https://user-images.githubusercontent.com/99636945/196833705-cf3527bb-a191-46d4-bbe5-e48fabf7bb28.png)

### 6-3. Git을 활용한 소프트웨어 버전 관리
- 소프트웨어 형상관리 중 소프트웨어 소스코드의 버전 관리를 지원하는 툴
#### 6-3.1. 초기 소스코드 버전관리
![image](https://user-images.githubusercontent.com/99636945/196833883-5915b153-de97-4de3-b696-5bcea16eb993.png)
![image](https://user-images.githubusercontent.com/99636945/196833911-936b707b-8513-40e3-a2fb-d4fbcf3d0760.png)
#### 6-3.2. Git을 활용한 소스 관리
- 1. Git Repository 생성
- Repository는 깃에서 소스코드를 저장하는 단위임
- 제품 단위로 repository를 생성하게 됨  
![image](https://user-images.githubusercontent.com/99636945/196834013-80888439-7b66-4aaf-9d46-61911b629260.png)
- 2. Git Repository 사용 방식
- 2-1. github에 있는 repository를 로컬PC로 동기화 후, 해당 디렉터리에 코드 작성  
![image](https://user-images.githubusercontent.com/99636945/196834122-5ff0026b-cf6a-4e71-bae3-245659ed7f08.png)
- 2-2. 기존 코드가 존재하던 디렉토리를 Repository와 연결  
![image](https://user-images.githubusercontent.com/99636945/196834213-04ed998f-93b5-43aa-bf70-ebfdcf38afba.png)
#### 6-3.3. Local PC에서 git 사용 시 환경 설정
- 사용자 단위 설정과 디렉토리 단위 설정이 존재
- 사용자 단위 설정은 해당 사용자가 생성한 디렉터리에 기본 적용
- 디렉터리 단위 설정은 해당 디렉터리의 Repository에만 적용되는 설정, 우선순위가 높음  
![image](https://user-images.githubusercontent.com/99636945/196834400-f6baded4-f181-40bb-9b57-22024a77aeb8.png)
- 대표적 설정값 : 사용자 이름, 이메일  
![image](https://user-images.githubusercontent.com/99636945/196834450-e9b5532a-5db6-455f-9d72-14a2b1c09d88.png)

### 6-4. 버전 관리
- 사용자에게 이미 출시된 제품에 대한 관리, Tag 기능을 사용해서 관리  
![image](https://user-images.githubusercontent.com/99636945/196834761-5ddd71b3-e08b-42a1-9da8-9bcde28059de.png)
- 통합 과정에서 발생하는 변경사항에 대한 관리
- 각각 개발자가 수정하면서 발생한 변경으로 인한 코드의 내용이 달라짐(버전이 달라진다고 함)
![image](https://user-images.githubusercontent.com/99636945/196834808-b6f866d3-8f8c-4b74-a211-12b62d98731a.png)
- 깃은 스냅샷 기반의 버전 관리를 사용함.
#### 6-4.1. 스냅샷 기반 버전 관리
- 파일에 변경을 발생시킨 후 저장할 때 마다 그 파일 상태를 온전히 저장하는 방식
- 여러 번 변경이 발생해도 그 시점의 파일 상태를 확인하는 것이 가능
- username, email로 판별
- Repository와 디렉토리의 관계를 표현할 수 있다  
![image](https://user-images.githubusercontent.com/99636945/196835033-94efaafc-830d-4fb2-9fb9-c40f6572237d.png)

### 6-5. Git 버전 관리 실습
- Github를 원격 저장소로 사용하는 경우
- 웹 브라우저를 통해 인증 시 자동으로 github에 로그인한 username, email 사용
- 자격증명 관리자 기능을 통해 처리
- .gitconfig를 통해 username, email 변경 가능  
![image](https://user-images.githubusercontent.com/99636945/196835276-004fa240-d37b-451a-ac8e-5d5b4f418911.png)

#### 6-5.1. 개발자들에게 공유
- Git Repository를 사용할 수 있게 해야함  
![image](https://user-images.githubusercontent.com/99636945/196835455-dd864332-f05b-4896-9a5e-011ca25fd6c0.png)

#### 6-5.2. 내가 작성한 코드 반영
- 1. Git local Repository에서 소스코드 변경하기  
![image](https://user-images.githubusercontent.com/99636945/196835552-6d930746-698b-453c-bbb6-23a771b177c9.png)
- 2. Local Repository의 상태 확인  
![image](https://user-images.githubusercontent.com/99636945/196835633-30ee6919-b10e-489d-ae6e-9859280533fd.png)
- 3. Git Repository에 소스코드 변경사항 추가  
![image](https://user-images.githubusercontent.com/99636945/196835748-f14bc267-538f-41a1-a9b8-4d3a0f7afb1c.png)
- 4. Git local Repository에 소스코드 변경사항을 영구적으로 반영  
![image](https://user-images.githubusercontent.com/99636945/196835879-82898c02-b2b1-4bd3-a51d-14709a8f4732.png)
![image](https://user-images.githubusercontent.com/99636945/196835991-5b470ccd-588c-4b6f-aede-ac4d12f09fd3.png)
- 커밋 시 메시지를 넣지 않으면 반드시 메세지를 넣으라며 에디터를 띄워줌
- 5. Git local Repository에 영구적으로 반영한 변경사항 확인  
![image](https://user-images.githubusercontent.com/99636945/196836100-0140af2c-666c-4c97-9096-a3eac9b99dd3.png)
![image](https://user-images.githubusercontent.com/99636945/196836129-25bb3fc0-d650-416a-8321-7996fd91691a.png)
- git show로 commit의 세부 내용을 확인할 수도 있다

# 7. Git을 이용한 소스코드 버전관리 방법
### 7-1. Commit Message 작성 요령
- 영문 작성 시 변경되는 내용에 대해 설명하되, 시작을 동사로 해 주면 좋다.  
![image](https://user-images.githubusercontent.com/99636945/198193309-e158262e-0fb7-4932-90ff-17935201b593.png)
- 한글 작성 시 변경되는 내용들에 대해 간단하게 설명하면 된다.  
![image](https://user-images.githubusercontent.com/99636945/198193347-7ecefaf7-cc1c-463b-8a39-ff9b22595275.png)
- Issue Tracker 사용 시, Issue Number를 Prefix로 사용할 수 있다.  
![image](https://user-images.githubusercontent.com/99636945/198193368-f52c71e0-2288-4d73-a20c-2f65d86851fa.png)
- 공통점은 특정 기능을 추가했을 때, 해당 기능과 관련된 내용들만 해당 Commit에 포함해야 한다는 것이다.
- 그렇게 해야 Commit Message도 자연스레 해당 기능만 설명하게 됨
- 여러 기능을 하나의 Commit에 포함하는 것은 변경사항 추적을 어렵게 만듬
![image](https://user-images.githubusercontent.com/99636945/198193589-65be1e4e-4c0a-4b76-8f8b-911259d4d991.png)

### 7-2. 최근 Commit 수정(Amend)
- Commit할 시 추가 기능에 대한 문서를 까먹을 때가 존재한다.
- 이때 git commit 시 --amend 옵션을 붙일 수 있는데, 기존의 최신 커밋에 변경사항을 추가해준다.
- git push 수행해서 동기화된 경우, amend 사용을 추천하지 않는다.
- 동작 원리는 다음과 같다.
![image](https://user-images.githubusercontent.com/99636945/198193812-34dc819e-0a38-44f3-b463-a17fb89f0b76.png)
- amend 이후 git push를 수행하려면 에러가 발생할 수 있는데, 원격 저장소와 로컬 저장소의 커밋 이력이 달라 동기화가 안되기 때문에 발생한다.
- 강제 Push를 하면 해결할 수 있는데, 다른 사용자와의 동기화 문제가 발생할 수 있다.
- 유용하게 쓰려면, 로컬 저장소에서 커밋 후 Push하지 않은 상황에서 수정해야 할 때 적절하다.
![image](https://user-images.githubusercontent.com/99636945/198195582-00898dc2-a101-472f-8867-3fa1a2d3e3ee.png)
![image](https://user-images.githubusercontent.com/99636945/198195683-edbcab7c-e825-43c4-9ec4-2fce39b56807.png)

### 7-3. Repository 변경 사항 파악
#### 7-3.1. 깃의 저장소 구조
- WorkSpace : 개발할 소프트웨어 소스코드가 저장된 디렉터리(Local Repository가 있는 디렉터리를 의미)
- Repository : Commit 된 소스코드 및 버전 관리를 위한 metadata 전체를 의미(.git Directory)
- Stage : 코드 변경 사항을 Commit을 통해 Repostiory에 반영할 때 포함될 대상을 임시 저장하는 영역
![image](https://user-images.githubusercontent.com/99636945/198196651-de349e4e-2767-42ef-a113-02df531273bc.png)

#### 7-3.2. Workspace 상태
- Dirty : 마지막 Commit과 대조하여 WorkSpace에 변경사항이 발생한 상태
- Clean : 마지막 Commit과 비교해서 WorkSpace에 변경사항이 없는 상태
- 변경사항 : 새로운 파일, 디렉터리 추가, git에 의해 관리되던 파일 및 디렉터리의 수정, 삭제, 이름 변경
![image](https://user-images.githubusercontent.com/99636945/198198298-4f0891f4-d477-4cba-a8de-e11e19d3c273.png)

### 7-4. 파일의 상태
- Untracked : 현재 WorkSpace에 존재하지만, 로컬 저장소의 현재 Commit엔 없음
- UnModified : 로컬 저장소의 현재 Commit에 있는 파일과 현재 WorkSpace 간 파일 상태가 동일한 경우
- Modified : 현재 WorkSpace에 있는 파일과 로컬 저장소의 현재 Commit에 있는 파일의 상태가 다를 경우
- Staged : 현재 Workspace에 파일이 있으며, 로컬 저장소의 현재 commit에도 파일이 있으며, 반영대상에 포함된 상태
![image](https://user-images.githubusercontent.com/99636945/198198542-bf8befc5-71b4-499b-98e5-440e7ac3dec3.png)

### 7-5. 변경내용 취소
- git Restore 명령을 사용하는데, 두 가지 방법이 존재한다.
- git restore : 수정한 소스코드 파일을 반영대상에 포함하기 전에 원래대로 되돌릴 때
- git restore --staged : 삭제한 소스코드 파일을 반영 대상에 포함했을 때 반영 대상에서 제외
![image](https://user-images.githubusercontent.com/99636945/198199107-cd2654da-6733-4ea1-8d1b-dd49c3f53f9b.png)

### 7-6. 소스코드 파일 삭제
- git rm 을 사용한다.(리눅스의 경우는 그냥 rm을 사용하지만, git 내에서 사용할 때에는 git rm을 사용해주면 된다.)
- 옵션이 없는 경우는 UnModified일 때에 사용할 수 있다.
![image](https://user-images.githubusercontent.com/99636945/198199495-1e4718c3-fcd6-496d-8673-800ad6621d54.png)
- Cached 옵션(Modified/Staged 일 때 사용) : WorkSpace 파일은 삭제하지 않고 Stage에 파일 삭제 변경사항을 등록함
![image](https://user-images.githubusercontent.com/99636945/198199514-ca3685c6-009c-4e82-906c-a4795f635f52.png)
- Force 옵션(Modified/Staged일 때 사용) : WorkSpace의 파일 삭제하고 Stage에 파일 삭제 변경사항을 등록함
![image](https://user-images.githubusercontent.com/99636945/198199550-6e6f7ecb-8b13-474a-9110-57e75c255b13.png)
- 리눅스 명령어 rm을 사용해서 삭제하면 Stage 영역에 파일 삭제 변경사항이 등록 되지 않음






